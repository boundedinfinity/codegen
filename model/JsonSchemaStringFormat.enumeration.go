////////////////////////////////////////////////////////////////////////
// Generated by bounded/enumeration
////////////////////////////////////////////////////////////////////////

package model

import (
	"encoding/json"
	"fmt"
	"strings"
)

type JsonSchemaStringFormat string

const (
	JsonSchemaStringFormat_Date                JsonSchemaStringFormat = "date"
	JsonSchemaStringFormat_DateTime            JsonSchemaStringFormat = "date-time"
	JsonSchemaStringFormat_Email               JsonSchemaStringFormat = "email"
	JsonSchemaStringFormat_IdnHostname         JsonSchemaStringFormat = "idn-hostname"
	JsonSchemaStringFormat_Ipv4                JsonSchemaStringFormat = "ipv4"
	JsonSchemaStringFormat_Ipv6                JsonSchemaStringFormat = "ipv6"
	JsonSchemaStringFormat_Iri                 JsonSchemaStringFormat = "iri"
	JsonSchemaStringFormat_IriReference        JsonSchemaStringFormat = "iri-reference"
	JsonSchemaStringFormat_JsonPointer         JsonSchemaStringFormat = "json-pointer"
	JsonSchemaStringFormat_Regex               JsonSchemaStringFormat = "regex"
	JsonSchemaStringFormat_RelativeJsonPointer JsonSchemaStringFormat = "relative-json-pointer"
	JsonSchemaStringFormat_Time                JsonSchemaStringFormat = "time"
	JsonSchemaStringFormat_Uri                 JsonSchemaStringFormat = "uri"
	JsonSchemaStringFormat_UriReference        JsonSchemaStringFormat = "uri-reference"
	JsonSchemaStringFormat_UriTemplate         JsonSchemaStringFormat = "uri-template"
)

var (
	JsonSchemaStringFormats = []JsonSchemaStringFormat{
		JsonSchemaStringFormat_Date,
		JsonSchemaStringFormat_DateTime,
		JsonSchemaStringFormat_Email,
		JsonSchemaStringFormat_IdnHostname,
		JsonSchemaStringFormat_Ipv4,
		JsonSchemaStringFormat_Ipv6,
		JsonSchemaStringFormat_Iri,
		JsonSchemaStringFormat_IriReference,
		JsonSchemaStringFormat_JsonPointer,
		JsonSchemaStringFormat_Regex,
		JsonSchemaStringFormat_RelativeJsonPointer,
		JsonSchemaStringFormat_Time,
		JsonSchemaStringFormat_Uri,
		JsonSchemaStringFormat_UriReference,
		JsonSchemaStringFormat_UriTemplate,
	}
)

func IsJsonSchemaStringFormat(v string) bool {
	var f bool

	for _, e := range JsonSchemaStringFormats {
		if string(e) == v {
			f = true
			break
		}
	}

	return f
}

func JsonSchemaStringFormatParse(v string) (JsonSchemaStringFormat, error) {
	var o JsonSchemaStringFormat
	var f bool
	n := strings.ToLower(v)

	for _, e := range JsonSchemaStringFormats {
		if strings.ToLower(e.String()) == n {
			o = e
			f = true
			break
		}
	}

	if !f {
		return o, ErrJsonSchemaStringFormatNotFound(v)
	}

	return o, nil
}

func ErrJsonSchemaStringFormatNotFound(v string) error {
	var ss []string

	for _, e := range JsonSchemaStringFormats {
		ss = append(ss, string(e))
	}

	return fmt.Errorf(
		"invalid enumeration type '%v', must be one of %v",
		v, strings.Join(ss, ","),
	)
}

func (t JsonSchemaStringFormat) String() string {
	return string(t)
}

func (t JsonSchemaStringFormat) MarshalJSON() ([]byte, error) {
	return json.Marshal([]byte(t))
}

func (t *JsonSchemaStringFormat) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	e, err := JsonSchemaStringFormatParse(s)

	if err != nil {
		return err
	}

	t = &e

	return nil
}
